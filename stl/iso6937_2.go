package stl

import (
	"unicode/utf8"

	"golang.org/x/text/transform"
	"golang.org/x/text/unicode/norm"
)

var decode = map[byte]rune{
	0x20: ' ', 0x21: '!', 0x22: '"', 0x23: '#', 0x24: '\u00a4', 0x25: '%', 0x26: '&', 0x27: '\'',
	0x28: '(', 0x29: ')', 0x2A: '*', 0x2B: '+', 0x2C: ',', 0x2D: '-', 0x2E: '.', 0x2F: '/',
	0x30: '0', 0x31: '1', 0x32: '2', 0x33: '3', 0x34: '4', 0x35: '5', 0x36: '6', 0x37: '7',
	0x38: '8', 0x39: '9', 0x3A: ':', 0x3B: ';', 0x3C: '<', 0x3D: '=', 0x3E: '>', 0x3F: '?',
	0x40: '@', 0x41: 'A', 0x42: 'B', 0x43: 'C', 0x44: 'D', 0x45: 'E', 0x46: 'F', 0x47: 'G',
	0x48: 'H', 0x49: 'I', 0x4A: 'J', 0x4B: 'K', 0x4C: 'L', 0x4D: 'M', 0x4E: 'N', 0x4F: 'O',
	0x50: 'P', 0x51: 'Q', 0x52: 'R', 0x53: 'S', 0x54: 'T', 0x55: 'U', 0x56: 'V', 0x57: 'W',
	0x58: 'X', 0x59: 'Y', 0x5A: 'Z', 0x5B: '[', 0x5C: '\\', 0x5D: ']', 0x5E: '^', 0x5F: '_',
	0x60: '`', 0x61: 'a', 0x62: 'b', 0x63: 'c', 0x64: 'd', 0x65: 'e', 0x66: 'f', 0x67: 'g',
	0x68: 'h', 0x69: 'i', 0x6A: 'j', 0x6B: 'k', 0x6C: 'l', 0x6D: 'm', 0x6E: 'n', 0x6F: 'o',
	0x70: 'p', 0x71: 'q', 0x72: 'r', 0x73: 's', 0x74: 't', 0x75: 'u', 0x76: 'v', 0x77: 'w',
	0x78: 'x', 0x79: 'y', 0x7A: 'z', 0x7B: '{', 0x7C: '|', 0x7D: '}', 0x7E: '~',

	0xA0: '\u00a0', 0xA1: '\u00a1', 0xA2: '\u00a2', 0xA3: '\u00a3', 0xA4: '$', 0xA5: '\u00a5', 0xA6: '#', 0xA7: '\u00a7',
	0xA8: '\u00a4', 0xA9: '\u2018', 0xAA: '\u201c', 0xAB: '\u00ab', 0xAC: '\u2190', 0xAD: '\u2191', 0xAE: '\u2192', 0xAF: '\u2193',
	0xB0: '\u00b0', 0xB1: '\u00b1', 0xB2: '\u00b2', 0xB3: '\u00b3', 0xB4: '\u00d7', 0xB5: '\u00b5', 0xB6: '\u00b6', 0xB7: '\u00b7',
	0xB8: '\u00f7', 0xB9: '\u2019', 0xBA: '\u201d', 0xBB: '\u00bb', 0xBC: '\u00bc', 0xBD: '\u00bd', 0xBE: '\u00be', 0xBF: '\u00bf',
	0xC1: '\u0300', 0xC2: '\u0301', 0xC3: '\u0302', 0xC4: '\u0303', 0xC5: '\u0304', 0xC6: '\u0306', 0xC7: '\u0307',
	0xC8: '\u0308', 0xCA: '\u030a', 0xCB: '\u0327', 0xCC: '\u0332', 0xCD: '\u030b', 0xCE: '\u0328', 0xCF: '\u030c',
	0xD0: '\u2015', 0xD1: '\u00b9', 0xD2: '\u00ae', 0xD3: '\u00a9', 0xD4: '\u2122', 0xD5: '\u266a', 0xD6: '\u00ac', 0xD7: '\u00a6',
	0xDC: '\u215b', 0xDD: '\u215c', 0xDE: '\u215d', 0xDF: '\u215e',
	0xE0: '\u2126', 0xE1: '\u00c6', 0xE2: '\u0110', 0xE3: '\u00aa', 0xE4: '\u0126', 0xE6: '\u0132', 0xE7: '\u013f',
	0xE8: '\u0141', 0xE9: '\u00d8', 0xEA: '\u0152', 0xEB: '\u00ba', 0xEC: '\u00de', 0xED: '\u0166', 0xEE: '\u014a', 0xEF: '\u0149',
	0xF0: '\u0138', 0xF1: '\u00e6', 0xF2: '\u0111', 0xF3: '\u00f0', 0xF4: '\u0127', 0xF5: '\u0131', 0xF6: '\u0133', 0xF7: '\u0140',
	0xF8: '\u0142', 0xF9: '\u00f8', 0xFA: '\u0153', 0xFB: '\u00df', 0xFC: '\u00fe', 0xFD: '\u0167', 0xFE: '\u014b', 0xFF: '\u00ad',
}

var encode = map[rune]byte{
	' ': 0x20, '!': 0x21, '"': 0x22, '#': 0x23, '\u00a4': 0x24, '%': 0x25, '&': 0x26, '\'': 0x27,
	'(': 0x28, ')': 0x29, '*': 0x2A, '+': 0x2B, ',': 0x2C, '-': 0x2D, '.': 0x2E, '/': 0x2F,
	'0': 0x30, '1': 0x31, '2': 0x32, '3': 0x33, '4': 0x34, '5': 0x35, '6': 0x36, '7': 0x37,
	'8': 0x38, '9': 0x39, ':': 0x3A, ';': 0x3B, '<': 0x3C, '=': 0x3D, '>': 0x3E, '?': 0x3F,
	'@': 0x40, 'A': 0x41, 'B': 0x42, 'C': 0x43, 'D': 0x44, 'E': 0x45, 'F': 0x46, 'G': 0x47,
	'H': 0x48, 'I': 0x49, 'J': 0x4A, 'K': 0x4B, 'L': 0x4C, 'M': 0x4D, 'N': 0x4E, 'O': 0x4F,
	'P': 0x50, 'Q': 0x51, 'R': 0x52, 'S': 0x53, 'T': 0x54, 'U': 0x55, 'V': 0x56, 'W': 0x57,
	'X': 0x58, 'Y': 0x59, 'Z': 0x5A, '[': 0x5B, '\\': 0x5C, ']': 0x5D, '^': 0x5E, '_': 0x5F,
	'`': 0x60, 'a': 0x61, 'b': 0x62, 'c': 0x63, 'd': 0x64, 'e': 0x65, 'f': 0x66, 'g': 0x67,
	'h': 0x68, 'i': 0x69, 'j': 0x6A, 'k': 0x6B, 'l': 0x6C, 'm': 0x6D, 'n': 0x6E, 'o': 0x6F,
	'p': 0x70, 'q': 0x71, 'r': 0x72, 's': 0x73, 't': 0x74, 'u': 0x75, 'v': 0x76, 'w': 0x77,
	'x': 0x78, 'y': 0x79, 'z': 0x7A, '{': 0x7B, '|': 0x7C, '}': 0x7D, '~': 0x7E,

	'\u00a0': 0xA0, '\u00a1': 0xA1, '\u00a2': 0xA2, '\u00a3': 0xA3, '$': 0xA4, '\u00a5': 0xA5, '\u00a7': 0xA7,
	'\u2018': 0xA9, '\u201c': 0xAA, '\u00ab': 0xAB, '\u2190': 0xAC, '\u2191': 0xAD, '\u2192': 0xAE, '\u2193': 0xAF,
	'\u00b0': 0xB0, '\u00b1': 0xB1, '\u00b2': 0xB2, '\u00b3': 0xB3, '\u00d7': 0xB4, '\u00b5': 0xB5, '\u00b6': 0xB6, '\u00b7': 0xB7,
	'\u00f7': 0xB8, '\u2019': 0xB9, '\u201d': 0xBA, '\u00bb': 0xBB, '\u00bc': 0xBC, '\u00bd': 0xBD, '\u00be': 0xBE, '\u00bf': 0xBF,
	'\u0300': 0xC1, '\u0301': 0xC2, '\u0302': 0xC3, '\u0303': 0xC4, '\u0304': 0xC5, '\u0306': 0xC6, '\u0307': 0xC7,
	'\u0308': 0xC8, '\u030a': 0xCA, '\u0327': 0xCB, '\u0332': 0xCC, '\u030b': 0xCD, '\u0328': 0xCE, '\u030c': 0xCF,
	'\u2015': 0xD0, '\u00b9': 0xD1, '\u00ae': 0xD2, '\u00a9': 0xD3, '\u2122': 0xD4, '\u266a': 0xD5, '\u00ac': 0xD6, '\u00a6': 0xD7,
	'\u215b': 0xDC, '\u215c': 0xDD, '\u215d': 0xDE, '\u215e': 0xDF,
	'\u2126': 0xE0, '\u00c6': 0xE1, '\u0110': 0xE2, '\u00aa': 0xE3, '\u0126': 0xE4, '\u0132': 0xE6, '\u013f': 0xE7,
	'\u0141': 0xE8, '\u00d8': 0xE9, '\u0152': 0xEA, '\u00ba': 0xEB, '\u00de': 0xEC, '\u0166': 0xED, '\u014a': 0xEE, '\u0149': 0xEF,
	'\u0138': 0xF0, '\u00e6': 0xF1, '\u0111': 0xF2, '\u00f0': 0xF3, '\u0127': 0xF4, '\u0131': 0xF5, '\u0133': 0xF6, '\u0140': 0xF7,
	'\u0142': 0xF8, '\u00f8': 0xF9, '\u0153': 0xFA, '\u00df': 0xFB, '\u00fe': 0xFC, '\u0167': 0xFD, '\u014b': 0xFE, '\u00ad': 0xFF,
}

// ISO6937 implements the ISO 6937 encoding.
// It implements the TextDecoder and TextEncoder interfaces.
var ISO6937 = iso6937{}

type iso6937 struct{}

// Decode decodes ISO 6937 encoded bytes into an UTF-8 encoded string.
func (e *iso6937) Decode(src []byte) ([]byte, error) {
	// Swap diacritics
	srcCopy := make([]byte, len(src))
	for i := 0; i < len(src); i++ {
		if src[i] >= 0xC1 && src[i] <= 0xCF {
			if i+1 < len(src) {
				srcCopy[i], srcCopy[i+1] = src[i+1], src[i]
				i++
			} else {
				return nil, transform.ErrShortSrc
			}
		} else {
			srcCopy[i] = src[i]
		}
	}

	// Decode
	var dst []byte
	for _, c := range srcCopy {
		result := make([]byte, utf8.UTFMax)
		var n int = 1

		if c <= 0x1F || (c >= 0x80 && c <= 0x9F) {
			result[0] = c
			n = 1
		} else if r, ok := decode[c]; ok {
			n = utf8.EncodeRune(result, r)
		} else {
			n = utf8.EncodeRune(result, '\uFFFD')
		}

		dst = append(dst, result[:n]...)
	}
	return dst, nil
}

// Encode encodes a UTF-8 encoded string into ISO 6937 encoded bytes.
func (e *iso6937) Encode(src []byte) ([]byte, error) {
	// Encode
	var dst []byte
	for _, c := range norm.NFD.String(string(src)) {
		var result byte
		if (c >= 0x00 && c <= 0x1F) || (c >= 0x80 && c <= 0x9F) {
			result = byte(c)
		} else if b, ok := encode[c]; ok {
			result = b
		} else {
			result = 0x3F
		}

		dst = append(dst, result)
	}

	// Swap diacritics
	for i, c := range dst {
		if c >= 0xC1 && c <= 0xCF {
			if i != 0 {
				dst[i-1], dst[i] = dst[i], dst[i-1]
			} else {
				return nil, transform.ErrShortSrc
			}
		}
	}

	return dst, nil
}
